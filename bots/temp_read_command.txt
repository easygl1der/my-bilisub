async def cmd_read(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Read and send files command"""
    user_id = update.effective_user.id

    # Check authorization
    if ALLOWED_USERS and user_id not in ALLOWED_USERS:
        await update.message.reply_text("âŒ æœªæˆæƒç”¨æˆ·")
        return

    # Parse input
    args = context.args if context.args else []
    if not args:
        await update.message.reply_text(
            "âŒ è¯·æä¾›è¦è¯»å–çš„ç›®å½•\n\n"
            "ç”¨æ³•: `/read <ç›®å½•è·¯å¾„>`\n\n"
            "ç¤ºä¾‹:\n"
            "â€¢ `/read test_downloads` - å‘é€æµ‹è¯•ä¸‹è½½ç›®å½•ä¸­çš„æ–‡ä»¶\n"
            "â€¢ `/read learning_notes` - å‘é€å­¦ä¹ ç¬”è®°\n"
            "â€¢ `/read output` - å‘é€è¾“å‡ºç›®å½•ä¸­çš„æ–‡ä»¶\n"
            "â€¢ `/read` - å‘é€é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰€æœ‰ç”Ÿæˆçš„æ–‡ä»¶",
            parse_mode="Markdown"
        )
        return

    # Get directory path
    dir_path_str = args[0] if len(args) >= 1 else "æ‰€æœ‰ç›®å½•"

    # Determine directory
    dir_mapping = {
        "test_downloads": PROJECT_ROOT / "test_downloads",
        "downloaded_videos": PROJECT_ROOT / "downloaded_videos",
        "output": PROJECT_ROOT / "output",
        "MediaCrawler": PROJECT_ROOT / "MediaCrawler",
        "learning_notes": PROJECT_ROOT / "learning_notes",
        "bili_comments": PROJECT_ROOT / "bili_comments_output",
        "xhs_comments": PROJECT_ROOT / "xhs_comments_output",
        "xhs_analysis": PROJECT_ROOT / "xhs_analysis",
        "xhs_images": PROJECT_ROOT / "xhs_images",
    }

    if dir_path_str == "æ‰€æœ‰ç›®å½•":
        # Read all output directories
        search_dirs = list(dir_mapping.values())
    else:
        if dir_path_str not in dir_mapping:
            await update.message.reply_text(
                f"âŒ æœªçŸ¥çš„ç›®å½•: `{dir_path_str}`\n\n"
                f"å¯ç”¨ç›®å½•:\n"
                f"{', '.join(dir_mapping.keys())}",
                parse_mode="Markdown"
            )
            return
        search_dirs = [dir_mapping.get(dir_path_str)]

    # Find and send files
    found_files = []
    for dir_path in search_dirs:
        if not dir_path.exists():
            continue

        for file in dir_path.rglob("*"):
            if file.is_file():
                size = file.stat().st_size
                size_mb = size / 1024 / 1024
                size_str = f"{size_mb:.2f} MB" if size_mb >= 1 else f"{size_mb*1024:.0f} KB"
                file_type = get_file_type(file)

                found_files.append({
                    "path": str(file),
                    "name": file.name,
                    "type": file_type,
                    "size_str": size_str
                })

    if not found_files:
        await update.message.reply_text(f"âŒ ç›®å½• `{dir_path_str}` ä¸­æ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶", parse_mode="Markdown")
        return

    await update.message.reply_text(
        f"ğŸ“‚ æ‰¾åˆ° **{len(found_files)}** ä¸ªæ–‡ä»¶\n\n"
        f"æ­£åœ¨å‘é€..."
    )

    # Send all files with bold text
    sent_count = 0
    for file_info in found_files[:10]:  # Send max 10 files at a time
        file_path = Path(file_info["path"])
        try:
            with open(file_path, "rb") as f:
                # Send with bold caption
                caption = f"**{file_info['type']}** - {file_info['name']} ({file_info['size_str']})"
                await update.effective_message.reply_document(
                    document=f,
                    filename=file_info["name"],
                    caption=caption,
                    disable_content_type_check=False
                )
                sent_count += 1
        except Exception as e:
            await update.message.reply_text(f"âš ï¸ å‘é€æ–‡ä»¶å¤±è´¥: {file_info['name']}\né”™è¯¯: {str(e)}")

    if sent_count < len(found_files):
        await update.message.reply_text(
            f"â³ ç»§ç»­å‘é€å‰©ä½™ {len(found_files) - sent_count} ä¸ªæ–‡ä»¶..."
        )
        sent_count += 0

    # Send remaining files
    for file_info in found_files[sent_count:]:
        file_path = Path(file_info["path"])
        try:
            with open(file_path, "rb") as f:
                caption = f"**{file_info['type']}** - {file_info['name']} ({file_info['size_str']})"
                await update.effective_message.reply_document(
                    document=f,
                    filename=file_info["name"],
                    caption=caption,
                    disable_content_type_check=False
                )
        except Exception as e:
            await update.message.reply_text(f"âš ï¸ å‘é€æ–‡ä»¶å¤±è´¥: {file_info['name']}\né”™è¯¯: {str(e)}")

    await update.message.reply_text(
        f"âœ… å®Œæˆï¼å…±å‘é€ {len(found_files)} ä¸ªæ–‡ä»¶\n\n"
        f"å¯ä»¥ç”¨ `/ask` ç»§ç»­å…¶ä»–æ“ä½œ"
    )
